## ARIN7001 Key Notes - summarized by hyperloop

## 1 Adv Math & Calculus Section
高等数学部分每年大约有6-7道题，主要考察积分方面知识，还会有一些关于可微性质、复合函数求导、约束优化、导数梯度等知识，这一部分知识点最杂乱，有些题还是会固定出现；

### 1.1 Math 题型1 可微性质
每年都会有一道题，证明某多元函数**在零点处可微**，这道题建议使用老师课件中讲过的方法进行证明；

![1764905130139](image/Key-Notes/1764905130139.png)

**根据往年经验，这些题额外创建的线性映射L一般都恒等于0，这非常重要**

**结合24-Math-Q1观看**
![1764905548050](image/Key-Notes/1764905548050.png)

---

### 1.2 Math 题型2 纯积分

#### 纯积分题：常规方法做不动时，如何选“换招”（方法选择指南）

> 目标：**不展开具体技巧**，只教你看到题目后如何快速判断该用  
> ①交换积分顺序 ②分布/概率积分 ③换元（含极坐标、线性变换等）

#### 1.2.0 先做 3 秒扫描（决定大方向）
- **看积分维度**：是一重还是二重/三重？是否有参数 \(a\)、是否反常（\(\infty\)、奇点）？
- **看结构信号**：有无绝对值、min/max、分段边界、\(x^2+y^2\)、\(xy\)、\(\sqrt{\cdot}\)、\(\ln\)、\(e^{-x}\)、\(e^{-x^2}\)、\(x^{p-1}(1-x)^{q-1}\) 等。
- **看“难点”来自哪**：是 **被积函数难** 还是 **积分区域/上下限难**？


#### 1.2.1 交换积分顺序（当“区域/上下限”是痛点）
**触发条件（出现 1 条就高度怀疑要换序）：**
- 二重积分的积分限嵌套很怪：\(\int \int_{g(x)}^{h(x)}\cdots\) 内层很难算
- 区域边界是曲线（抛物线/圆弧/双曲线）或需要分段描述
- 出现 \(\min,\max,|x-y|\) 这类典型“分区”结构
- 你发现：**换序后内层能变成“立刻可积”的形式**（例如对某个变量变成指数/幂函数/多项式）


#### 1.2.2 分布/概率积分
**触发条件：**
- 区间是 \(0\to\infty\) 或 \(-\infty\to\infty\)，并出现
  - \(e^{-x}\)、\(x^{a-1}e^{-x}\)（像指数/伽马）
  - \(e^{-x^2}\)、\(e^{-(x^2+y^2)}\)（像正态）
  - \(x^{p-1}(1-x)^{q-1}\)（像 Beta）
- 题目看起来在算“某个区域上的密度积分”或“期望/概率”
- 积分整体不像初等函数能表达，但像 **Gamma/Beta/高斯积分** 可落地


**三步走（考试可直接套）**
1. **配形**：把表达式整理成“密度核 × 常数”的样子（必要时补一个常数再除回去）。
2. **换身份**：把积分写成
   - 概率：\(\int f = \mathbb P(\cdot)\)
   - 期望：\(\int g(x) f(x)\,dx = \mathbb E[g(X)]\)
   - 或直接对应到 Gamma/Beta/高斯模板。
3. **回代常数**：最后把你“补/除”的常数、比例系数、尺度参数都还原。


#### 1.2.3 换元（当“表达式/对称性”提示变量应被重新编码）
**触发条件：**
- 被积函数/区域出现结构性组合：
  - \(x^2+y^2\)、\(\sqrt{x^2+y^2}\) → 强烈提示极坐标/径向变量
  - \(xy\)、\(y/x\)、\((ax+by)\) → 常提示构造 \(u,v\)（乘积/比值/线性组合）
- 区域具有明显几何对称（圆、扇形、椭圆、平行四边形等）
- 你能把“复杂边界”通过换元变成“矩形/圆盘/简单区间”

**一句话判断：**
> **题目在“变量组合”上很有规律（平方和、乘积、线性组合）或区域有几何对称 → 换元。**

#### 换元法总结（重点：二维/三维极坐标与常见雅可比）

##### 换元的核心（一定要写出 Jacobian）
把变量从 \((x,y)\) 或 \((x,y,z)\) 换成更“贴合区域/被积函数”的新变量，并用
\[
dx\,dy = \left|\frac{\partial(x,y)}{\partial(u,v)}\right| du\,dv,\qquad
dx\,dy\,dz = \left|\frac{\partial(x,y,z)}{\partial(u,v,w)}\right| du\,dv\,dw
\]
其中绝对值就是 **Jacobian（雅可比）**。


##### 二维：极坐标（Polar）
##### 适用信号
- 被积函数含 \(x^2+y^2\)、\(\sqrt{x^2+y^2}\)、或区域是圆/扇形/环形
- 旋转对称明显

##### 变量替换与面积元
\[
x=r\cos\theta,\quad y=r\sin\theta,\quad r\ge 0
\]
\[
dx\,dy = r\,dr\,d\theta
\]

##### 边界处理口诀
- 圆/环：直接变成 \(r\) 的区间
- 扇形：\(\theta\) 先定范围，再写 \(r\) 的范围
- 一般曲线：把边界方程改写成 \(r=f(\theta)\) 或 \(\theta=g(r)\)


##### 三维：柱坐标（Cylindrical）
##### 适用信号
- 对 \(z\) 方向“直上直下”结构明显（柱体、圆柱、绕 \(z\) 轴旋转的立体）
- 出现 \(x^2+y^2\) 但同时还有 \(z\)

##### 变量替换与体积元
\[
x=r\cos\theta,\quad y=r\sin\theta,\quad z=z
\]
\[
dx\,dy\,dz = r\,dr\,d\theta\,dz
\]
（顺序可写成 \(r\,dr\,d\theta\,dz\) 或 \(r\,dr\,dz\,d\theta\)，看边界哪个更好写）

##### 边界处理口诀
- 先确定 \((r,\theta)\) 的“底面区域”，再给出 \(z\) 的上下界：\(z\in[z_{\min}(r,\theta), z_{\max}(r,\theta)]\)

##### 三维：球坐标（Spherical，最常用版）
> 你说的 “\(r\,dr\,d\alpha\,d\beta\)” 多数对应球坐标的两个角（记号因教材不同）。

##### 适用信号
- 出现 \(x^2+y^2+z^2\) 或球/球冠/球壳
- 立体对称性强（关于原点或某轴）

##### 常见定义（物理/工科常用）
\[
x=\rho\sin\varphi\cos\theta,\quad
y=\rho\sin\varphi\sin\theta,\quad
z=\rho\cos\varphi
\]
范围通常：
\[
\rho\ge0,\quad \theta\in[0,2\pi),\quad \varphi\in[0,\pi]
\]
体积元：
\[
dx\,dy\,dz = \rho^2\sin\varphi\,d\rho\,d\varphi\,d\theta
\]

> 若你用 \(\alpha,\beta\) 表示两角：一般就是把 \(\theta\leftrightarrow \alpha\)，\(\varphi\leftrightarrow \beta\) 记号改名即可，关键是 **\(\rho^2\sin(\text{极角})\)** 这一项别漏。

##### 换元选型速记（考场判断）
- 看到 **\(x^2+y^2\)** → 优先极坐标/柱坐标
- 看到 **\(x^2+y^2+z^2\)** → 优先球坐标
- 区域像“绕轴旋转” → 柱坐标
- 区域像“球/球壳/球冠” → 球坐标


##### 高频易错点（丢分重灾区）
- **忘记 Jacobian**：二维漏 \(r\)，三维球坐标漏 \(\rho^2\sin\varphi\)
- **角度范围写错**：\(\theta\) 通常 \(0\to2\pi\)，极角 \(\varphi\) 通常 \(0\to\pi\)
- **边界没翻译干净**：一定把原边界用新变量改写成 \(r/\rho,\theta,\varphi\) 的不等式




#### 1.2.4 决策树（考试上直接用）
1) **难点主要来自积分域/上下限？**  
   - 是 → 先想 **换序**
2) **被积函数像经典核（指数/高斯/幂×指数/Beta形）？**  
   - 是 → 优先 **分布积分**
3) **出现 \(x^2+y^2\) 或明显对称/几何形状？**  
   - 是 → 优先 **换元（极坐标/适配几何）**
4) **都不明显**：  
   - 先尝试“画域 + 看哪种切片更简单”（回到换序）
   - 或尝试把表达式配成某个已知核（回到分布积分）
   - 或寻找能把边界变直的变量组合（回到换元）


---
### 1.3 Math 题型3 极值点

#### 找候选点（critical points）
对可微函数 \(f(x_1,\dots,x_n)\)：
\[
\nabla f = 0 \quad \Longleftrightarrow \quad 
\frac{\partial f}{\partial x_1}=0,\dots,\frac{\partial f}{\partial x_n}=0
\]
解这个方程组得到所有驻点（候选极值点）。

#### 计算 Hessian（海森矩阵）
在每个驻点 \(x^*\) 处计算二阶偏导，组成海森矩阵：
\[
H(x^*)=
\begin{pmatrix}
\frac{\partial^2 f}{\partial x_1^2} & \cdots & \frac{\partial^2 f}{\partial x_1\partial x_n}\\
\vdots & \ddots & \vdots\\
\frac{\partial^2 f}{\partial x_n\partial x_1} & \cdots & \frac{\partial^2 f}{\partial x_n^2}
\end{pmatrix}_{x=x^*}
\]

#### 用正定性判定（核心结论）
- 若 \(H(x^*)\) **正定**（对任意非零向量 \(v\)，有 \(v^\top H v>0\)）  
  👉 \(f\) 在 \(x^*\) 处有**严格局部极小值**。

- 若 \(H(x^*)\) **负定**（对任意非零向量 \(v\)，有 \(v^\top H v<0\)）  
  👉 \(f\) 在 \(x^*\) 处有**严格局部极大值**。

- 若 \(H(x^*)\) **不定**（有的 \(v\) 使 \(v^\top H v>0\)，有的 \(v\) 使 \(v^\top H v<0\)）  
  👉 \(x^*\) 是**鞍点**，不是极值点。

- 若 \(H(x^*)\) **半正定 / 半负定**（总是 \(\ge 0\) 或 \(\le 0\)，但存在非零 \(v\) 使 \(v^\top H v=0\)）  
  👉 **无法仅凭二阶判断**，需要进一步用高阶项或别的方法分析。

#### 二元函数 \(f(x,y)\) 的常用判据（特例记忆版）
对
\[
H=
\begin{pmatrix}
f_{xx} & f_{xy}\\
f_{yx} & f_{yy}
\end{pmatrix}
\]
记
\[
D = f_{xx}f_{yy} - f_{xy}^2
\]

在驻点处：

- 若 \(D>0\) 且 \(f_{xx}>0\)：局部极小值  
- 若 \(D>0\) 且 \(f_{xx}<0\)：局部极大值  
- 若 \(D<0\)：鞍点  
- 若 \(D=0\)：二阶判别法失效，需要另行分析

---


### 1.4 Math 题型4 链式求导
**结合23-Math-Q6观看**
![1764903311487](image/Key-Notes/1764903311487.png)
![1764903381012](image/Key-Notes/1764903381012.png)

---

## 2 Stat & Prbability Section
**概率论与数理统计部分，每年考察的题型，非常一致，永远是：**
- 一道联合分布
- 一到线性回归最小二乘法推导
- 一道贝叶斯网络


### 2.1 Stat 题型1 联合分布
概率联合分布这道题通常来说都没有什么难度，只需要记清变量**独立分布**的定义就行；

---

### 2.2 Stat 题型2
**最小二乘法这道题一共有两个考点：**
- 第1个考点是损失函数最小二乘闭式解推导
- 第2个考点是最小解是否唯一

#### Stat 2.2.1 最小二乘闭式解推导
对于第1个考点，损失函数闭式解的推导又分为几种情况，包括：
- 基本型
- Bias trick
- 含正则化项
- 含bias（应该不考）

这部分没什么好说的，直接背下来闭式解的公式就可以;

#### Stat 2.2.1.1 基本型
![1764855904697](image/Key-Notes/1764855904697.png)


#### Stat 2.2.1.2 Bias trick
![1764856084018](image/Key-Notes/1764856084018.png)

#### Stat 2.2.1.3 含正则化项
![1764856895763](image/Key-Notes/1764856895763.png)

#### Stat 2.2.1.4 含Bias（应该不考）
![1764856129542](image/Key-Notes/1764856129542.png)
![1764856154333](image/Key-Notes/1764856154333.png)

#### Stat 2.2.2 最小解唯一性
![1764856477797](image/Key-Notes/1764856477797.png)
![1764856487663](image/Key-Notes/1764856487663.png)
![1764856499629](image/Key-Notes/1764856499629.png)
![1764856514929](image/Key-Notes/1764856514929.png)

---

### 2.3 Stat 题型3 贝叶斯网络
三个常见考点
- 变量独立判断
- 条件概率计算
- 最大似然估计

#### 变量独立判断技巧
![1764914504573](image/Key-Notes/1764914504573.png)
![1764914517209](image/Key-Notes/1764914517209.png)

---

## 3 Data Structure & Algorithm Section

### Time Complexity
![1764936948993](image/CS-Review/1764936948993.png)
![1764936880690](image/CS-Review/1764936880690.png)

---

## 常见数据结构：操作时间复杂度速查表（Big-O）

> 说明  
> - n：元素个数；h：树高；α(n)：反阿克曼函数（几乎可视为常数）  
> - “平均/均摊”常见于哈希、动态数组扩容等场景  
> - 不同实现会有常数差异，但数量级规律基本一致

---

### 1) 数组 / 动态数组（Array / Dynamic Array, 如 Python list 的“动态数组”部分）

| 操作 | 访问/修改 by index | 查找(无序) | 查找(有序, 二分) | 末尾追加 append | 末尾删除 pop | 头部/中间插入 | 头部/中间删除 | 扩容 |
|---|---:|---:|---:|---:|---:|---:|---:|---:|
| 时间复杂度 | O(1) | O(n) | O(log n) | 均摊 O(1)（最坏 O(n)） | O(1) | O(n) | O(n) | 最坏 O(n) |

---

### 2) 链表（Linked List）

| 操作 | 访问第 k 个 | 查找 | 已知结点插入/删除 | 头插/头删 | 尾插/尾删（无尾指针） | 尾插/尾删（有尾指针，单链表） |
|---|---:|---:|---:|---:|---:|---:|
| 单链表 | O(n) | O(n) | 插入 O(1)，删除通常 O(1)\* | O(1) | O(n) | 尾插 O(1)，尾删 O(n) |
| 双链表 | O(n) | O(n) | 插入/删除 O(1) | O(1) | O(1)\*\* | O(1)\*\* |

\* 单链表删除“已知结点”通常还需要其前驱；若已给前驱则 O(1)，否则要找前驱 O(n)。  
\*\* 双链表若维护 tail 指针，尾插/尾删可 O(1)。

---

### 3) 栈 / 队列 / 双端队列（Stack / Queue / Deque）

| 结构 | 主要操作 | 时间复杂度 |
|---|---|---:|
| 栈 Stack | push / pop / top | O(1) |
| 队列 Queue | enqueue / dequeue / front | O(1) |
| 双端队列 Deque | push_front / push_back / pop_front / pop_back | O(1) |

> 注：若用“普通动态数组”硬做队列的 `pop(0)` 会变成 O(n)。

---

### 4) 哈希表（Hash Table / Dict / Map）

| 操作 | 插入 | 删除 | 查找 | 遍历全部 |
|---|---:|---:|---:|---:|
| 平均/均摊 | O(1) | O(1) | O(1) | O(n) |
| 最坏 | O(n) | O(n) | O(n) | O(n) |

> 最坏通常来自哈希冲突极端或被攻击输入；工程上会用随机化/扩容/更好的哈希策略缓解。

---

### 5) 二叉搜索树 BST / 平衡树 AVL/红黑树（Balanced BST）

| 结构 | 查找 | 插入 | 删除 | 最坏树高 |
|---|---:|---:|---:|---:|
| 普通 BST（不平衡） | O(h)（最坏 O(n)） | O(h)（最坏 O(n)） | O(h)（最坏 O(n)） | h 最坏 = n |
| 平衡 BST（AVL/红黑树） | O(log n) | O(log n) | O(log n) | h = O(log n) |

---

### 6) 二叉堆（Binary Heap：最小堆/最大堆）

| 操作 | 取堆顶 peek | 插入 push | 删除堆顶 pop | decrease/increase-key | 建堆 build-heap | 堆排序 heapsort |
|---|---:|---:|---:|---:|---:|---:|
| 时间复杂度 | O(1) | O(log n) | O(log n) | O(log n) | O(n) | O(n log n) |

---

### 7) 排序算法（常见对比）

| 算法 | 平均 | 最坏 | 最好 | 额外空间 | 稳定性 |
|---|---:|---:|---:|---:|---|
| 快排 QuickSort | O(n log n) | O(n^2) | O(n log n) | 递归栈 O(log n)~O(n) | 通常不稳定 |
| 归并 MergeSort | O(n log n) | O(n log n) | O(n log n) | O(n) | 稳定 |
| 堆排 HeapSort | O(n log n) | O(n log n) | O(n log n) | O(1) | 不稳定 |
| 插入 Insertion | O(n^2) | O(n^2) | O(n) | O(1) | 稳定 |
| 选择 Selection | O(n^2) | O(n^2) | O(n^2) | O(1) | 不稳定(常见实现) |
| 冒泡 Bubble | O(n^2) | O(n^2) | O(n)\* | O(1) | 稳定 |

\* 带“提前终止”优化时最好 O(n)。

---

## 二叉堆（最大堆）的基本操作

> 记号：堆大小为 `n`，结点索引从 0 开始  
> `parent(i)=(i-1)//2`，`left(i)=2i+1`，`right(i)=2i+2`  
> 堆高度 `h = ⌊log2 n⌋`



### 0. 堆的常见基本操作（Max-Heap）

### A) 取最大值 `HEAP-MAXIMUM`
- **步骤**：直接返回 `A[0]`
- **时间复杂度**：`O(1)`

### B) 插入 `MAX-HEAP-INSERT(x)`（上滤 / sift-up）
- **步骤**
  1. 把 `x` 追加到数组末尾（堆尾）
  2. 令 `i = last_index`
  3. while `i>0` 且 `A[parent(i)] < A[i]`：交换 `A[i]` 与 `A[parent(i)]`，令 `i = parent(i)`
- **时间复杂度**：`O(log n)`（最多上滤一条根路径）

### C) 删除最大值 `HEAP-EXTRACT-MAX`（下滤 / sift-down）
- **步骤**
  1. 保存 `max = A[0]`
  2. 用最后一个元素覆盖根：`A[0] = A[n-1]`，堆大小 `n--`
  3. 对根执行 `MAX-HEAPIFY(0)`
  4. 返回 `max`
- **时间复杂度**：`O(log n)`

### D) 增大某个键值 `HEAP-INCREASE-KEY(i, newKey)`
- **前提**：`newKey >= A[i]`
- **步骤**：令 `A[i]=newKey`，然后像插入一样不断与父结点交换（上滤）
- **时间复杂度**：`O(log n)`

---

### 1. MAX-HEAPIFY（维护最大堆性质，向下调整）

### 作用
当某个结点 `i` 可能比子结点小（常见于“根被替换”“局部破坏”），`MAX-HEAPIFY(i)` 通过**下滤**恢复以 `i` 为根的子树的最大堆性质。  
**关键前提**：`i` 的左右子树（如果存在）本身已经是最大堆。

### 操作步骤（递归/迭代都行）
1. `l = left(i)`, `r = right(i)`
2. 在 `i,l,r` 中找值最大的结点 `largest`
3. 如果 `largest != i`：
   - 交换 `A[i]` 与 `A[largest]`
   - 令 `i = largest`，继续对新的 `i` 做 `MAX-HEAPIFY`

### 时间复杂度
- 只会沿高度向下走最多 `h` 层  
- **`O(log n)`**

---

### 2. BUILD-MAX-HEAP（把无序数组建成最大堆）

### 核心思想
从**最后一个非叶子结点**开始，自底向上对每个结点做 `MAX-HEAPIFY`。  
因为叶子本身就是堆（无需处理），越靠下的结点下滤成本越低。

### 操作步骤
1. 堆大小 `heap_size = n`
2. 对 `i = ⌊n/2⌋ - 1, ⌊n/2⌋ - 2, ..., 0`：
   - 调用 `MAX-HEAPIFY(i)`

### 时间复杂度（重点！）
- 不是 `O(n log n)`，而是 **`O(n)`**  
- 直觉：大量结点在底层，`heapify` 走不了几层；只有少量上层结点才可能走很深。

---

### 3. HEAPSORT（堆排序）

### 思想
先建最大堆（最大值在根），反复把根（最大值）交换到数组末尾，并缩小堆，再对根 `heapify`。

### 操作步骤
1. `BUILD-MAX-HEAP(A)`
2. for `i = n-1` down to `1`：
   - 交换 `A[0]` 与 `A[i]`（把当前最大值放到最终位置）
   - `heap_size--`（末尾已排好，不再属于堆）
   - `MAX-HEAPIFY(0)`（恢复最大堆）

### 时间复杂度
- 建堆：`O(n)`
- 循环执行 `n-1` 次，每次 `heapify`：`O(log n)`
- 总计：**`O(n log n)`**

### 额外性质
- **原地排序**：额外空间 `O(1)`（不算递归栈）
- **非稳定**：相等元素相对次序可能改变


---

## 二叉树：中序遍历(inorder)导航 + 插入/删除相关函数总结（指针实现）

> 默认结点结构：每个结点有 `left / right / parent` 指针  
> 中序顺序：**Left subtree → Node → Right subtree**

---

### 1) 中序遍历的“导航”函数（Navigation）

#### 1.1 `subtree_first(X)`：找以 X 为根的子树的**第一个**（最左）
- 规则：从 `X` 出发，一直走 `left`，直到 `left == None`
- 返回：该最左结点
- 复杂度：O(h)（h 为树高）

#### 1.2 `subtree_last(X)`：找以 X 为根的子树的**最后一个**（最右）
- 规则：从 `X` 出发，一直走 `right`，直到 `right == None`
- 返回：该最右结点
- 复杂度：O(h)

#### 1.3 `successor(X)`：找 X 的**中序后继**（下一个）
- 情况 A：`X.right != None`
  - 后继 = `subtree_first(X.right)`（右子树最左）
- 情况 B：`X.right == None`
  - 往上爬：当 `X` 是其父结点的 **right child** 时继续上爬
  - 第一次遇到 `X` 是父结点的 **left child**，那个父结点就是后继
  - 如果爬到根都没找到：后继不存在（X 已是最后一个）
- 复杂度：O(h)

#### 1.4 `predecessor(X)`：找 X 的**中序前驱**（上一个）
- 完全对称：
  - 若 `X.left != None`：前驱 = `subtree_last(X.left)`
  - 否则往上爬：当 `X` 是父结点的 **left child** 时继续上爬；第一次遇到 `X` 是 **right child** 的父结点就是前驱
- 复杂度：O(h)

---

### 2) 插入函数：`insert_after(X, Y)`（把新结点 Y 插到 X 的“中序后面”）

> 这类插入是基于“中序顺序=序列”的树结构（Sequence Tree）  
> **注意：它不按 key 比较，因此一般不保证 BST 的有序性。**

前提：Y 是“新结点”，通常 `Y.left = Y.right = None`

#### 2.1 若 `X.right == None`
- 直接挂：`X.right = Y`
- `Y.parent = X`
- 为什么正确：中序访问 X 后就会进入 X 的右子树，Y 作为右孩子会立刻成为下一个

#### 2.2 若 `X.right != None`
- 令 `Z = subtree_first(X.right)`（X 右子树最左结点）
- 因为 Z 是最左，所以 `Z.left == None`
- 插入：`Z.left = Y`，`Y.parent = Z`
- 为什么正确：中序访问 X 后进入右子树，最先到达的就是右子树最左 Z；把 Y 放在 Z 的左边，Y 会比 Z 更早被访问，从而紧跟在 X 后面

复杂度：O(h)（主要花在找 `subtree_first`）

---

### 3) 删除函数：`delete(X)`（保持中序序列不乱）

常用辅助：`transplant(U, V)`  
- 含义：用子树 V 替换子树 U 的位置（更新 `parent` 指针）
- 用途：把“某结点从树上摘掉，并把它的孩子接上去”

#### 3.1 X 没有孩子（叶子）
- 直接把父结点指向 X 的那条边置空
- 复杂度：O(1)

#### 3.2 X 只有一个孩子
- 用它的唯一孩子替换它：`transplant(X, X.left)` 或 `transplant(X, X.right)`
- 复杂度：O(1)

#### 3.3 X 有两个孩子（最经典）
做法：用 **X 的中序后继 S** 来替换 X（S 一定在 X 的右子树，且 S 没有左孩子）
- `S = successor(X)`（等价于 `subtree_first(X.right)`）
- 分两种：

**(a) S 就是 X 的右孩子**
- 直接 `transplant(X, S)`
- 再令 `S.left = X.left`，并更新 `X.left.parent = S`

**(b) S 不直接是 X.right（S 在右子树更深处）**
1. `transplant(S, S.right)`：先把 S 从原位置拿走（S 没左孩子，所以只可能带一个右孩子）
2. 把 X 的右子树接到 S：`S.right = X.right`，并更新 `S.right.parent = S`
3. `transplant(X, S)`：用 S 替换 X
4. 把 X 的左子树接到 S：`S.left = X.left`，并更新 `S.left.parent = S`

复杂度：O(h)（找后继 + 若干次 transplant）


